Daily Coding:

Day 4:

//Generate Finonacci sequence

function generateFibonacci(arr,n){
    let fibonacciSeries=arr;
   for(let i=2;i<n;i++){
       let nextFibonacci=fibonacciSeries[i-2]+fibonacciSeries[i-1];
       fibonacciSeries.push(nextFibonacci);
   }
   return fibonacciSeries;
}

console.log(generateFibonacci([10,20],8));

--------------------------------------------------------------------------------------

//Two sum

function twoSum(a,t){
    let finalArr=[];
    for(let i=0;i<a.length;i++){
        for(let j=i+1;j<a.length;j++){
            if(a[i]+a[j]===t){
                finalArr.push([i,j]);
            }
        }
    }
    return finalArr;
}
const arr=[3,2,4];//[2,7,11,15]---target-9
const target=6;
//Output: [0,1]----> Indexes Array
console.log(twoSum(arr,target));


Approach 2:

function twoSum(arr, target) {
  let obj = {};

  for (let i = 0; i < arr.length; i++) {
    if (target - arr[i] in obj) {
       return [obj[target-arr[i]], i];
    } else {
      obj[arr[i]] = i;
    }
  }
  return [];
};

twoSum([7,11,15,2], 15);


----------------------------------------------------------------------------
// Balanced paranthesis
console.log(matchingParenthesis("{(Ebere) [Njoku](Samson)}"));

function matchingParenthesis(str){
   // Remove the characters in a string and keep only special characters
   let paranthesis="[{()}]";
  let openParams=["[","{","("];
  let closeParams=["]","}",")"];
  let stack=[];
  //Keep only paranthesis
 let filteredStr=str.split("").filter(e=>[...paranthesis].includes(e));
  
  
  //Push the open Paranthesis inside a stack
  // If we encounter any close Paranthesis , then get the last index element of the stack
  //Check for index of last stack element in open Params array and compare it with element in closeParams
 for(let i of filteredStr){
     if(openParams.includes(i)){
         stack.push(i);
     }else{
         let lastElem=stack[stack.length-1];
         if(closeParams.indexOf(i)===openParams.indexOf(lastElem)){
             stack.pop(lastElem);
         }else {
              return "closing brace does not match opening brace";
            }
     }
    
 }
 if (stack.length !== 0) return "braces do not match";
        return "All openning brace has a closing brace to match";
}


----------------------------------------------------------------
Day 9: How Many Numbers Are Smaller Than the Current Number 

Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.
For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).

nums = [8,1,2,2,3];
console.log(smallerNumThanCurrent(nums));
function smallerNumThanCurrent(nums){
    let countArr=[];
  for(let i=0;i<nums.length;i++){
       let count=0;
      for(let j=0;j<nums.length;j++){
          if(nums[j]<nums[i]){
              count++;
          }
      }
      countArr.push(count);
  }  
  return countArr;
}



-----------------------------------------------------------------------------------

//Split Strings by Separator

// Example 1:

// Input: words = ["one.two.three","four.five","six"], separator = "."
// Output: ["one","two","three","four","five","six"]

const  words = ["one.two.three","four.five","six"], separator = ".";
console.log(threeSumClosest(words, separator));
function threeSumClosest(words, separator){
   console.log(words.join(separator).split(separator).filter(Boolean));
}

//array.filter(Boolean)--- Filters the falsy values and returns the array but it does not mutate the original array.

