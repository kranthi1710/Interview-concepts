Daily Coding:

Day 4:

//Generate Finonacci sequence

function generateFibonacci(arr,n){
    let fibonacciSeries=arr;
   for(let i=2;i<n;i++){
       let nextFibonacci=fibonacciSeries[i-2]+fibonacciSeries[i-1];
       fibonacciSeries.push(nextFibonacci);
   }
   return fibonacciSeries;
}

console.log(generateFibonacci([10,20],8));

--------------------------------------------------------------------------------------

//Two sum

function twoSum(a,t){
    let finalArr=[];
    for(let i=0;i<a.length;i++){
        for(let j=i+1;j<a.length;j++){
            if(a[i]+a[j]===t){
                finalArr.push([i,j]);
            }
        }
    }
    return finalArr;
}
const arr=[3,2,4];//[2,7,11,15]---target-9
const target=6;
//Output: [0,1]----> Indexes Array
console.log(twoSum(arr,target));


Approach 2:

function twoSum(arr, target) {
  let obj = {};

  for (let i = 0; i < arr.length; i++) {
    if (target - arr[i] in obj) {
       return [obj[target-arr[i]], i];
    } else {
      obj[arr[i]] = i;
    }
  }
  return [];
};

twoSum([7,11,15,2], 15);


----------------------------------------------------------------------------
// Balanced paranthesis
console.log(matchingParenthesis("{(Ebere) [Njoku](Samson)}"));

function matchingParenthesis(str){
   // Remove the characters in a string and keep only special characters
   let paranthesis="[{()}]";
  let openParams=["[","{","("];
  let closeParams=["]","}",")"];
  let stack=[];
  //Keep only paranthesis
 let filteredStr=str.split("").filter(e=>[...paranthesis].includes(e));
  
  
  //Push the open Paranthesis inside a stack
  // If we encounter any close Paranthesis , then get the last index element of the stack
  //Check for index of last stack element in open Params array and compare it with element in closeParams
 for(let i of filteredStr){
     if(openParams.includes(i)){
         stack.push(i);
     }else{
         let lastElem=stack[stack.length-1];
         if(closeParams.indexOf(i)===openParams.indexOf(lastElem)){
             stack.pop(lastElem);
         }else {
              return "closing brace does not match opening brace";
            }
     }
    
 }
 if (stack.length !== 0) return "braces do not match";
        return "All openning brace has a closing brace to match";
}
